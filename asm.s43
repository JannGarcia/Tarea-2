#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

        ORG     0x1C00                  ; RAM starting location
                                        ; Always define it when working with arrays
                                        ; or saving a variable to RAM directly
                                        

;============================= ARRAY DEFINITIONS/SETUP =========================
; Arrays need to be defined BEFORE "init"

; Digits        0     1     2     3     4      5      6      7      8     9
digitH  DB      0xFC, 0x60, 0xDB, 0xF3, 0x00,  0x00,  0x00,  0x00,  0x00, 0x00
digitL  DB      0x20, 0x00, 0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00, 0x00

;===============================================================================

init:   MOV     #SFE(CSTACK), SP        ; set up stack


UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activade
                                        ; previously configured port settings
setupDisplayAndPorts:
        ; Manage Ports 
        BIS.b #11111001B, &P1DIR   ; set P1.1/2 to input 
        MOV.b #00000110B, &P1REN   ; Activate P1.1/2 pull-up/down resistors
        BIS.b #11111001B, &P1OUT   ; set P1.1/2 pull down resistor
        BIS.b #BIT0,&P1OUT         ; set P1.0 LED off 

        ; Enable LCD segments: 0-21, 26-43
        MOV #0xFFFF, &LCDCPCTL0         ; 1111111111111111
        MOV #0xFC3F, &LCDCPCTL1         ; 1111110000111111, Q: why the 0's? Why ignore 22-25?
        MOV #0x0FFF, &LCDCPCTL2         ; 1111111111111111
          
        ; Initialize LCD 
        MOV #0x041e,&LCDCCTL0           ; sets display with hardware specs needed
        MOV #0x0208, &LCDCVCTL          ; enable voltage for display
        MOV #0x8000, &LCDCCPCTL         ; enable clock synchronization
        MOV #2, &LCDCMEMCTL             ; clear LCD memory (resets screen)
        BIS #1, &LCDCCTL0               ; turn the LCD on

main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer


; Everything under here will loop each time the program finishes
mainLoop:
        CALL    #reset                  ; Reset all needed registers/values
        CALL    #startProgram
        JMP     mainLoop
        
        CALL    #endProgram             ; Never runs, as mainLoop goes on forever


; Perform "Housekeeping" -- where we set every register/value to a default val
reset:
        MOV     #0, R4                  ; R4 = Current Page/State
                                        ;       0 = Title       <-- start
                                        ;       1 = Name Loop
                                        ;       2 = Menu
                                        ;       ...

        MOV     #0, R5                  ; R5 = Current Substate
                                        ;       R4 = 1
                                        ;       * 0 = Name 1
                                        ;       * 1 = Name 2
                                        ;       * 2 = Name 3
                                        ;       * 3 = Name 4

        RET
        
        
startProgram:
        CALL    #displayCurrentPage
        
        
        ; TODO: Loop until a condition signifying "end" is reached
        ; Currently we are checking if R4 is >= number_of_states

        CMP     #3, R4
        JL     startProgram
        
        RET                             ; Jump back to "main"
        

; Call the respective page's subroutine. 
; NOTE: The subroutine should eventually increase R4 to allow
displayCurrentPage:
        CMP     #0, R4
        CALL    #displayTitleScreen     ; Maybe we need to use CALL instead of JMP.
                                        ; Same goes for below.
        
        CMP     #1, R4
        CALL    #displayNames
        
        CMP     #2, R4
        CALL    #displayMenu

        RET                             ; Return back to "startProgram"
        


displayTitleScreen:
        ; TODO: Loop until S1 or S2 is pressed.
          ; If S1 is pressed -- R4 = 1
          ; If S2 is pressed -- R4 = 2

        ; TODO:
          ; Maybe label what these moves do?
        MOV.b   #0x8E, &0xA29
        MOV.b   #0x22, &0xA26
        MOV.b   #0xCF, &0xA23
        MOV.b   #0x01, &0xA24
        MOV.b   #0xFC, &0xA32
        MOV.b   #0x02, &0xA33
        MOV.b   #0x88, &0xA2F
        
        RET


displayNames:
        CMP     #0, R5
        JEQ     displayName1
        
        CMP     #1, R5
        JEQ     displayName2        
        
        CMP     #2, R5
        JEQ     displayName3        
        
        CMP     #3, R5
        JEQ     displayName4
        
        RET
        
displayName1:
        ; TODO: display Name 1
        RET                             ; Jump back to "displayCurrentPage"
        
displayName2:
        ; TODO: display Name 2
        RET                             ; Jump back to "displayCurrentPage"

displayName3:
        ; TODO: display Name 3
        RET                             ; Jump back to "displayCurrentPage"
        
displayName4:
        ; TODO: display Name 4
        RET                             ; Jump back to "displayCurrentPage"
        
        
displayMenu:
        RET                             ; Jump back to "displayCurrentPage"



endProgram:
        JMP $                           ; jump to current location '$'
                                        ; (endless loop)

        NOP
        END
