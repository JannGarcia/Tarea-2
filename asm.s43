#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        ORG     0x1C00                  ; RAM starting location
                                        ; Always define it when working with arrays
                                        ; or saving a variable to RAM directly

;============================= NOTES ===========================================
; * Everything commented with // is debug code.
;===============================================================================

;============================= TODOs ===========================================
; 1) Render period
; 2) Render a sign if signed == true (+/-) and decimal == true
                                        

;============================= ARRAY DEFINITIONS/SETUP =========================
; Arrays need to be defined BEFORE "init"

; Input Buttons
S1      db 00000100B 
S2      db 00000010B

;Letters and Symbols
;            A     B     C     D     E     F     G     H     I     J     K     L     M     N     O     P     Q     R     S     T     U     V     W     X     Y     Z   NONE    -     >     ?
;            0     1     2     3     4     5     6     7     8     9     10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25   26    27    28    29
CharH   db 0xEF, 0xF1, 0x9C, 0xF0, 0x9F, 0x8E, 0xBD, 0x6F, 0x00, 0x78, 0x00, 0x1C, 0x6C, 0x6C, 0xFC, 0xCF, 0xFC, 0xCF, 0xB7, 0x80, 0x7C, 0x0C, 0x6C, 0x00, 0x00, 0x90, 0x00, 0x03, 0x00, 0xC5
CharL   db 0x00, 0x50, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x72, 0x00, 0xB0, 0x82, 0x00, 0x00, 0x02, 0x02, 0x00, 0x50, 0x00, 0x28, 0x0A, 0xAA, 0xB0, 0x28, 0x00, 0x00, 0x88, 0x10

; Digits        0     1     2     3     4      5      6      7      8     9
digitH  DB      0xFC, 0x60, 0xDB, 0xF3, 0x67,  0xB7,  0xBF,  0xE0,  0xFF, 0xE7
digitL  DB      0x20, 0x00, 0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00, 0x00

;               N       Y       
yesNoH  DB      0x6C, 0x00
yesNoL  DB      0x82, 0xB0 


;Names
JANN    db 9,  0, 13, 13, 26, 26
VANDIE  db 21, 0, 13,  3,  8, 4
ISABEL  db 8, 18, 0, 1,  4, 11
RICARD  db 17,  8,  2, 0, 17, 3


inputNumber DW  0, 0, 0, 0, 0, 0

;
signQuest db 18, 8, 6, 13, 29           ;Signed Question
dtbQuest db 3, 27, 28, 1, 29            ;dec to bin question
digitDis db 3, 6, 19, 18, 29            ;Display DGTS?
bitsDis db 1, 8, 19, 18, 29             ;Display BITS?
errorDis db 4, 17, 17, 14, 17, 26       ; Display ERROR


;===============================================================================

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

init:   MOV     #SFE(CSTACK), SP        ; set up stack


main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer


UnlockGPIO:                             ; Disable de GPIO power-on default
        BIC     #LOCKLPM5,&PM5CTL0        ; high-impedance mode to activade
                                        ; previously configured port settings

setupDisplayAndPorts:
        ; Manage Ports 
        ; Port 1
        MOV.b   #11111001B, &P1DIR        ; set P1.1/2 to input (input = 0)
        MOV.b   #00000110B, &P1REN        ; Activate P1.1/2 pull-up/down resistors
        BIS.b   #00000110B, &P1OUT        ; set P1.1/2 pull down resistor
        BIC.b   #BIT0,&P1OUT              ; set P1.0 LED off 


        // Port 9 (DEBUG -- Only for LED)
        BIS.b   #0xFF,&P9DIR              ; Set all P9 pins for output
        BIC.b   #0x80,&P9OUT              ; set P9.7 LED off


        ; Enable LCD segments: 0-21, 26-43
        MOV     #0xFFFF, &LCDCPCTL0     ; 1111111111111111
        MOV     #0xFC3F, &LCDCPCTL1     ; 1111110000111111, Q: why the 0's? Why ignore 22-25?
        MOV     #0x0FFF, &LCDCPCTL2     ; 1111111111111111
          
        ; Initialize LCD 
        MOV     #0x041e,&LCDCCTL0       ; sets display with hardware specs needed
        MOV     #0x0208, &LCDCVCTL      ; enable voltage for display
        MOV     #0x8000, &LCDCCPCTL     ; enable clock synchronization
        MOV     #2, &LCDCMEMCTL         ; clear LCD memory (resets screen)
        BIS     #1, &LCDCCTL0            ; turn the LCD on



; Everything under here will loop each time the program finishes
mainLoop:
        CALL    #reset                  ; Reset all needed registers/values
        CALL    #startProgram
        JMP     mainLoop
        
        CALL    #endProgram             ; Never runs, as mainLoop goes on forever


;=================================== Clear Input Number Subroutine =============
clearInputNumber:
        PUSH.b    R4                      ; Store R4
        MOV     #0, R4

clearLoop:
        MOV     #0, inputNumber(R4)
        INCD    R4                      ; R4 += 2
        CMP     #12, R4                 
        JL      clearLoop
        POP.b     R4
        
        RET
;===============================================================================

;================================== RESET SUBROUTINE ===========================
; Perform "Housekeeping" -- where we set every register/value to a default val
reset:
        MOV     #0, R4                  ; R4 = Current Page/State
                                        ;       0 = Title       <-- start
                                        ;       1 = Name Loop
                                        ;       2 = Menu -- Question 1 (Sign?)
                                        ;       3 = Menu -- Question 2 (D --> B)
                                        ;       4 = Menu -- Question 3.a (Digs?)
                                        ;       5 = Menu -- Question 3.b (Bits?)
                                        ;       6 = Input Number Screen
                                        ;       7 = Error
                                        ;       8 = Conversion State
                                                
                                        ;       ...

        MOV     #0, R5                  ; R5 = Current Name
                                        ;       * 0 = Name 1
                                        ;       * 1 = Name 2
                                        ;       * 2 = Name 3
                                        ;       * 3 = Name 4

        MOV     #1, R6                  ; R6 = Signed/Unsigned boolean (1 = Y, 0 = N)
        MOV     #1, R7                  ; R7 = Dec -> Bin boolean / delay register (1 = Y, 0 = N)
        MOV     #0, R8                  ; R8 = # of integer bits [0-6 binary, 1-2 decimal]

        MOV     #0, R9                  ; R9 = P1 Value (S1 = Bit 1, S2 = Bit 2)

        MOV     #0, R10                 ; R10 = InputNumber Index

        MOV     #2, &LCDCMEMCTL         ; clear LCD memory (resets screen)
    
        CALL    #clearInputNumber

        RET
        
;================================== RESET SUBROUTINE END =======================
        
startProgram:
        
        CALL    #checkButtonInput
        CALL    #displayCurrentPage
        
        
        ; Temporary check to determine if we need to continue looping
        ; see TODO's #4
        CMP     #9, R4
        JL      startProgram
        
        RET                             ; Jump back to "main"


;=========================== CHECK BUTTON SUBROUTINE ===========================
checkButtonInput:
        ; Check if S1 was pressed
        ; If S1 was pressed, do an action based on the current page

        MOV.b   &P1IN, R9               ; Get button state from P1 
        AND.b   #00000110B, R9          ; Apply bit mask to value
        CMP.b   S1, R9          ; Check if S1 was pressed (sets to 0 when pressed)
        
        ; Skip to checking S2
        JNE     checkS2                 ; S1 wasn't pressed, check S2
        
        ; Call a delay, in case it was a false alarm
        CALL    #delay
        
        ; Check once again. If it's true, it should be correct
        MOV.b   &P1IN, R9               ; Get button state from P1 
        AND.b   #00000110B, R9          ; Apply bit mask to value

        ; Check if S1 was unpressed (sets to 0 when pressed)
        ; This is to prevent holding the button
        CMP.b   S1, R9          

        JNE     jumpToPerformActionForS1
        JMP     endButtonCheck
        
checkS2:           
        ; Check if S2 was pressed
        ; If S2 was pressed, do an action based on the current page

        MOV.b   &P1IN, R9               ; Get button state from P1 
        AND.b   #00000110B, R9          ; Apply bit mask to value
        CMP.b   S2, R9          ; Check if S2 was pressed (sets to 0 when pressed)
        
        JNE     endButtonCheck          ; S2 wasn't pressed, end button check
        
        ; Call a delay, in case it was a false alarm
        CALL    #delay
        
        
        ; Check once again. If it's true, it should be correct
        MOV.b   &P1IN, R9               ; Get button state from P1 
        AND.b   #00000110B, R9          ; Apply bit mask to value

        ; Check if S2 was unpressed (sets to 0 when pressed)
        ; This is to prevent holding the button
        CMP.b   S2, R9         
        JNE     jumpToPerformActionForS2
        JMP     endButtonCheck
                
jumpToPerformActionForS1:
        CALL    #performActionForS1
        JMP     endButtonCheck
        
jumpToPerformActionForS2:
        CALL    #performActionForS2
        
endButtonCheck:
//        // DEBUG: Turn LEDs OFF
//        CMP.b   #0x6, R9
//        JEQ     turnOffLEDs
//        RET                             ; Return back to "startProgram"

//turnOffLEDs:
//        BIC.b   #BIT0, &P1OUT
//        BIC.b   #0x80, &P9OUT
        RET                             ; Return back to "startProgram"
        
;=========================== CHECK BUTTON SUBROUTINE END========================


;=============================== S1 BUTTON ACTION ==============================

performActionForS1:
        // DEBUG: Turn P1.0 ON and P9.7 OFF
        BIS.b   #BIT0, &P1OUT
        BIC.b   #0x80, &P9OUT
;        CALL    #delay                  // Show the LED
        
        CMP     #0, R4
        JEQ     performS1ActionForPage0 ; Title Page
        
        CMP     #1, R4
        JEQ     performS1ActionForPage1 ; Name Loop Page
        
        CMP     #2, R4
        JEQ     performS1ActionForPage2 ; Signed or Unsigned?
        
        CMP     #3, R4
        JEQ     performS1ActionForPage3 ; Dec --> Bin?
        
        CMP     #4, R4
        JEQ     performS1ActionForPage4 ; Digits? 
        
        CMP     #5, R4
        JEQ     performS1ActionForPage5 ; Bits?
        
        CMP     #6, R4
        JEQ     performS1ActionForPage6 ; Number Input
        
        CMP     #7, R4
        JEQ     performS1ActionForPage7 ; Error
        
        CMP     #8, R4
        JEQ     performS1ActionForPage8 ; Conversion State
        
; We need to check what page we are on!
; Depending on the page, we need to perform different actions:
        
performS1ActionForPage0:        ; Title
        ; R4 = 1
        MOV     #1, R4
        JMP     endS1Action
        
        
performS1ActionForPage1:        ; Name Loop
        ; R5++ % 4
        INC     R5
        CMP     #4, R5
        JL      endS1Action
        MOV     #0, R5                  ; Reset R5
        JMP     endS1Action



performS1ActionForPage2:        ; Signed or Unsigned?
        ; Toggle R6
        XOR     #BIT0, R6
        JMP     endS1Action

        
performS1ActionForPage3:        ; Dec --> Bin?
        ; Toggle R7
        XOR     #BIT0, R7
        JMP     endS1Action
        
performS1ActionForPage4:        ; Digits?
        ; Toggle R8
        XOR     #BIT0, R8
        JMP     endS1Action

        
performS1ActionForPage5:        ; Bits?
        ; R8++ % 7
        INC     R8
        CMP     #7, R8
        JL      endS1Action
        MOV     #0, R8                  ; Reset R8
        JMP     endS1Action


        
performS1ActionForPage6:        ; Number Choosing

        ; Check if we are in binary mode
        CMP     #0, R7
        JEQ     increaseBinaryDigit
        
        ; Increase Decimal Digit
        INC     inputNumber(R10)                ; Increase digit
        CMP     #0xA, inputNumber(R10)         ; Check if it has reached 10
        JL     endS1Action
        
        MOV     #0, inputNumber(R10)           ; If so, reset it to 0

        JMP     endS1Action
        
increaseBinaryDigit:
        XOR     #1, inputNumber(R10)            ; Invert value
        JMP     endS1Action

performS1ActionForPage7:        ; Error
        ; R4 = 6
        MOV     #6, R4
        JMP     endS1Action
        
performS1ActionForPage8:        ; Conversion State
        ; R4 = 9
        MOV     #9, R4                  ; This will cause the program to loop "mainLoop"

endS1Action:
        RET                             ; Return to "startProgram"

;=============================== S1 BUTTON ACTION END===========================

;=============================== S2 BUTTON ACTION ==============================

performActionForS2:
        // DEBUG: Turn P1.0 OFF and P9.7 ON
        BIC.b   #BIT0, &P1OUT
        BIS.b   #0x80, &P9OUT
;        CALL    #delay                  // Show the LED
        
        CMP     #0, R4
        JEQ     performS2ActionForPage0
        
        CMP     #1, R4
        JEQ     performS2ActionForPage1
        
        CMP     #2, R4
        JEQ     performS2ActionForPage2
        
        CMP     #3, R4
        JEQ     performS2ActionForPage3
        
        CMP     #4, R4
        JEQ     performS2ActionForPage4
        
        CMP     #5, R4
        JEQ     performS2ActionForPage5
        
        CMP     #6, R4
        JEQ     performS2ActionForPage6
        
        CMP     #7, R4
        JEQ     performS2ActionForPage7
        
        CMP     #8, R4
        JEQ     performS2ActionForPage8
        
; We need to check what page we are on!
; Depending on the page, we need to perform different actions:
                
performS2ActionForPage0:        ; Title
        ; R4 = 2
        MOV     #2, R4
        JMP     endS2Action
        
performS2ActionForPage1:        ; Name Loop
        ; R4 = 2
        MOV     #2, R4
        JMP     endS2Action
        
performS2ActionForPage2:        ; Sign?
        ; R4 = 3
        MOV     #3, R4
        JMP     endS2Action

performS2ActionForPage3:        ; Dec --> Bin?
        ; R4 = 4 if R7 = 1, else R4 = 5
        MOV     #4, R4
        
        CMP     #1, R7
        JEQ     endS2Action
        
        ; Digits was chosen
        INC.b   R4
        JMP     endS2Action

        
performS2ActionForPage4:        ; Digs?
        ; R4 = 6
        MOV     #6, R4
        JMP     endS2Action

performS2ActionForPage5:        ; Bits?
        ; R4 = 6
        MOV     #6, R4
        JMP     endS2Action
        
performS2ActionForPage6:        ; Number Choosing
        
        INCD     R10             ; Increase Index
        CMP     #12, R10         ; Check if we are still within index range
        JL      endS2Action
        
        
        ; Move to Conversion
        ; TODO:
        ; check if number is greater than 64, or do conversion
        MOV     #8, R4
        JMP     endS2Action
        
performS2ActionForPage7:        ; Error
        ; R4 = 6
        MOV     #6, R4
        JMP     endS2Action
        
performS2ActionForPage8:        ; Conversion
        ; R4 = 9
        MOV     #9, R4                  ; This will cause the program to loop "mainLoop"
        
endS2Action:
        RET
        

;=============================== S2 BUTTON ACTION END===========================
        

;=========================== DISPLAY SUBROUTINE ================================

displayCurrentPage:
        CMP     #0, R4                  
        JEQ     displayTitleScreen      ; Maybe we need to use CALL instead of JMP.
                                        ; Same goes for below.
        
        CMP     #1, R4
        JEQ     displayNames
        
        CMP     #2, R4
        JEQ     displaySignedQuestion
        
        CMP     #3, R4
        JEQ     displayDecToBinQuestion
        
        CMP     #4, R4
        JEQ     displayDigitsQuestion
        
        CMP     #5, R4
        JEQ     displayBitsQuestion
        
        CMP     #6, R4
        JEQ     displayNumberInput
        
        CMP     #7, R4
        JEQ     displayError
        
        CMP     #8, R4
        JEQ     displayConversion        
        ; ...
        
        ; CMP     #2, R4
        ; JEQ     displayMenu
        
        RET


displayTitleScreen:

        MOV.b   #0x8E, &0xA29           ; F
        MOV.b   #0x22, &0xA26           ; (
        MOV.b   #0xCF, &0xA23           ; P
        MOV.b   #0x01, &0xA24           ; .
        MOV.b   #0xFC, &0xA32           ; Q
        MOV.b   #0x02, &0xA33           ; Q (line)
        MOV.b   #0x88, &0xA2F           ; )
        
        RET                             ; Return back to "startProgram"


displayNames:
        ; IDEA: We might not even need to have all these indexings!
        ; We can just simply use R5 as the index to the name arrays
        ; That way all we do is:
        ;       * Display R5th Name
        ;       * Return
        CMP     #0, R5
        JEQ     displayName1
        
        CMP     #1, R5
        JEQ     displayName2        
        
        CMP     #2, R5
        JEQ     displayName3        
        
        CMP     #3, R5
        JEQ     displayName4
        
        
displayName1:
        MOV.B   #0xCF, &0xA29           ;R high byte
        MOV.B   #0x02, &0xA2A           ;R low byte
        MOV.B   #0x90, &0xA25           ;I high byte
        MOV.B   #0x50, &0xA26           ;I low byte
        MOV.B   #0x9C, &0xA23           ;C high byte
        MOV.B   #0x00, &0xA24           ;C low byte
        MOV.B   #0xEF, &0xA32           ;A high byte
        MOV.B   #0x00, &0xA33           ;A low byte
        MOV.B   #0xCF, &0xA2E           ;R high byte
        MOV.B   #0x02, &0xA2F           ;R low byte
        MOV.B   #0xF0, &0xA27           ;D high byte
        MOV.B   #0x50, &0xA28           ;D low byte
;        MOV.W #RICARD, R10
        RET                             ; Return back to "startProgram"
        
displayName2:
        MOV.B #0x78 , &0xA29            ;J high byte
        MOV.B #0x00 , &0xA2A            ;J low byte
        MOV.B #0xEF , &0xA25            ;A high byte
        MOV.B #0x00 , &0xA26            ;A low byte
        MOV.B #0x6C , &0xA23            ;N high byte
        MOV.B #0x82 , &0xA24            ;N low byte
        MOV.B #0x6C , &0xA32            ;N high byte
        MOV.B #0x82 , &0xA33            ;N low byte
        MOV.B #0x00 , &0xA2E            ;empty
        MOV.B #0x00 , &0xA2F            ;empty
        MOV.B #0x00 , &0xA27            ;empty
        MOV.B #0x00 , &0xA28            ;empty
        ;MOV.W #JANN, R10
        RET                             ; Return back to "startProgram"

displayName3:
        MOV.B   #0x90, &0xA29           ;I high byte
        MOV.B   #0x50, &0xA2A           ;I low byte
        MOV.B   #0xB1, &0xA25           ;S high byte
        MOV.B   #0x80, &0xA26           ;S low byte
        MOV.B   #0xEF, &0xA23           ;A high byte
        MOV.B   #0x00, &0xA24           ;A low byte
        MOV.B   #0xF1, &0xA32           ;B high byte
        MOV.B   #0x50, &0xA33           ;B low byte
        MOV.B   #0x9F, &0xA2E           ;E high byte
        MOV.B   #0x00 , &0xA2F          ;E low byte
        MOV.B   #0x1C, &0xA27           ;L high byte
        MOV.B   #0x00 , &0xA28          ;L low byte
;        MOV.W #ISABEL, R10
        RET                             ; Return back to "startProgram"
        
displayName4:
        MOV.B   #0x0C, &0xA29           ;V high byte
        MOV.B   #0x28, &0xA2A           ;V low byte
        MOV.B   #0xEF, &0xA25           ;A high byte
        MOV.B   #0x00, &0xA26           ;A low byte
        MOV.B   #0x6c, &0xA23           ;N high byte
        MOV.B   #0x82, &0xA24           ;N low byte
        MOV.B   #0xF0, &0xA32           ;D high byte
        MOV.B   #0x50, &0xA33           ;D low byte
        MOV.B   #0x90, &0xA2E           ;I high byte
        MOV.B   #0x50, &0xA2F           ;I high byte
        MOV.B   #0x9F, &0xA27           ;E high byte
        MOV.B   #0x00 , &0xA28          ;E low byte
;        MOV.W #VANDIE, R10
        RET                             ; Return back to "startProgram"
        
        
; displayMenu:
;         RET                             ; Return back to "startProgram"


        
        
displaySignedQuestion:
        MOV.B   #0xB1, &0xA29           ;S high byte
        MOV.B   #0x80, &0xA2A           ;S low byte
        MOV.B   #0x90, &0xA25           ;I high byte
        MOV.B   #0x50, &0xA26           ;I low byte
        MOV.B   #0xBD, &0xA23           ;G high byte
        MOV.B   #0x00, &0xA24           ;G low byte
        MOV.B   #0x6c, &0xA32           ;N high byte
        MOV.B   #0x82, &0xA33           ;N low byte
        MOV.B   #0xC5, &0xA2E           ;Question Mark high byte
        MOV.B   #0x10, &0xA2F           ;Question Mark low byte

        MOV.B   yesNoH(R6), &0xA27           ;Y/N high bit
        MOV.B   yesNoL(R6), &0xA28           ;Y/N low bit

        RET
        
displayDecToBinQuestion:
        ; TODO: Check if sign is TRUE.
        ; If it is, render a negative for the first digit
        MOV.B   #0xF0, &0xA29           ;D high byte
        MOV.B   #0x50, &0xA2A           ;D low byte
        MOV.B   #0x03, &0xA25           ;Arrow line high byte
        MOV.B   #0x00 , &0xA26          ;Arrow line low byte
        MOV.B   #0x00, &0xA23           ;Arrow head high byte
        MOV.B   #10001000B, &0xA24      ;Arrow head low byte
        MOV.B   #0xF1, &0xA32           ;B high byte
        MOV.B   #0x50, &0xA33           ;B low byte
        MOV.B   #0xC5, &0xA2E           ;Question Mark high byte
        MOV.B   #0x10, &0xA2F           ;Question Mark low byte

        MOV.B   yesNoH(R7), &0xA27           ;Y/N high bit
        MOV.B   yesNoL(R7), &0xA28           ;Y/N low bit

        RET
        
displayDigitsQuestion:
        MOV.B   #0xF0, &0xA29           ;D high byte
        MOV.B   #0x50, &0xA2A           ;D low byte
        MOV.B   #0xBD, &0xA25           ;G high byte
        MOV.B   #0x00, &0xA26           ;G low byte
        MOV.B   #0x80, &0xA23           ;T high byte
        MOV.B   #0x50, &0xA24           ;T low byte
        MOV.B   #0xB1, &0xA32           ;S high byte
        MOV.B   #0x80, &0xA33           ;S low byte
        MOV.B   #0xC5, &0xA2E           ;Question Mark high byte
        MOV.B   #0x10, &0xA2F           ;Question Mark low byte

        ; Hacky workaround to increasing index by 1 :V
        PUSH.b  R8
        INC    R8

        MOV.B   digitH(R8), &0xA27           ;Digit high bit
        MOV.B   digitL(R8), &0xA28           ;Digit low bit

        POP.b     R8


        RET
        
displayBitsQuestion:
        MOV.B   #0xF1, &0xA29           ;B high byte
        MOV.B   #0x50, &0xA2A           ;B low byte
        MOV.B   #0x90, &0xA25           ;I high byte
        MOV.B   #0x50, &0xA26           ;I low byte
        MOV.B   #0x80, &0xA23           ;T high byte
        MOV.B   #0x50, &0xA24           ;T low byte
        MOV.B   #0xB1, &0xA32           ;S high byte
        MOV.B   #0x80, &0xA33           ;S low byte
        MOV.B   #0xC5, &0xA2E           ;Question Mark high byte
        MOV.B   #0x10, &0xA2F           ;Question Mark low byte
        
        MOV.B   digitH(R8), &0xA27           ;Digit high bit
        MOV.B   digitL(R8), &0xA28           ;Digit low bit


        RET
        
displayNumberInput:
        PUSH.w  R11                     ; digit Index
        PUSH.w  R12                     ; Input Number Index
        MOV     #0, R11
        MOV     #0, R12
        
        ; Digit 0
        MOV     inputNumber(R12), R11
        MOV.B   digitH(R11),  &0xA29
        MOV.B   digitL(R11) , &0xA2A         
        
        ; Digit 1
        INCD    R12
        MOV     inputNumber(R12), R11
        MOV.B   digitH(R11),  &0xA25           
        MOV.B   digitL(R11) , &0xA26  

        ; Digit 2
        INCD    R12
        MOV     inputNumber(R12), R11
        MOV.B   digitH(R11),  &0xA23           
        MOV.B   digitL(R11) , &0xA24
        
        ; Digit 3
        INCD    R12
        MOV     inputNumber(R12), R11     
        MOV.B   digitH(R11),  &0xA32           
        MOV.B   digitL(R11) , &0xA33
        
        ; Digit 4
        INCD    R12
        MOV     inputNumber(R12), R11
        MOV.B   digitH(R11),  &0xA2E           
        MOV.B   digitL(R11) , &0xA2F
        
        ; Digit 5
        INCD     R12
        MOV     inputNumber(R12), R11
        MOV.B   digitH(R11),  &0xA27           
        MOV.B   digitL(R11) , &0xA28  


        POP     R11
        POP     R12
        RET
        
displayError:
        MOV.B   #0x9F, &0xA29           ;E high byte
        MOV.B   #0x00 , &0xA2A          ;E low byte
        MOV.B   #0xCF, &0xA25           ;R high byte
        MOV.B   #0x02, &0xA26           ;R low byte
        MOV.B   #0xCF, &0xA23           ;R high byte
        MOV.B   #0x02, &0xA24           ;R low byte
        MOV.B   #0xFC, &0xA32           ;O high byte
        MOV.B   #0x00, &0xA33           ;O low byte
        MOV.B   #0xCF, &0xA2E           ;R high byte
        MOV.B   #0x02, &0xA2F           ;R low byte
        MOV.B   #0x00, &0xA27           ;Empty
        MOV.B   #0x00, &0xA28           ;Empty
        RET
        
displayConversion:
          RET

;=========================== DISPLAY SUBROUTINE ================================


;=========================== DELAY SUBROUTINE ==================================
delay:  ; Used to delay the program
        ; giving the MSP time to handle
        ; button pressed (debouncing)

        PUSH.w    R7                      ; Preserve Original Value                       
        CALL    #delayStart
        POP     R7                      ; Restore Original Value
        RET
        
delayStart:
        MOV     #0xFFFF,R7              ; Set R7 to an abnormally high value       


next:   ; Decrease R7 all the way to 0
        DEC     R7                       
        JNZ     next
        RET
;=========================== DELAY SUBROUTINE ==================================



endProgram:
        JMP $                           ; jump to current location '$'
                                        ; (endless loop)

        NOP
        END
