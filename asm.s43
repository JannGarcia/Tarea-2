#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment

        ORG     0x1C00                  ; RAM starting location
                                        ; Always define it when working with arrays
                                        ; or saving a variable to RAM directly

;============================= NOTES ===========================================
; * Everything commented with // is debug code.
;===============================================================================

;============================= TODOs ===========================================
; 1) Setup buttons
;       * Values need to be cleared and stuff.
;       * Handle in "reset"?
                                   
; 2) State 6 Button Handling
                                        
; 3) Add all letters/digits as arrays (separating by high/low)

; 4) Loop until a condition signifying "end" is reached
;       * Currently we are checking if R4 is >= number_of_states

; 5) Define checkButtonInput subroutine
                                        

;============================= ARRAY DEFINITIONS/SETUP =========================
; Arrays need to be defined BEFORE "init"

; Digits        0     1     2     3     4      5      6      7      8     9
digitH  DB      0xFC, 0x60, 0xDB, 0xF3, 0x00,  0x00,  0x00,  0x00,  0x00, 0x00
digitL  DB      0x20, 0x00, 0x00, 0x00, 0x00,  0x00,  0x00,  0x00,  0x00, 0x00

;               Y    N       
yesNoH  DB      0x00, 0x6C
yesNoL  DB      0xB0, 0x82

;               S    U
SorUH   DB      0xB7, 0x7C
SorU_L  DB      0x00, 0x00

;===============================================================================

init:   MOV     #SFE(CSTACK), SP        ; set up stack


main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer


UnlockGPIO:                             ; Disable de GPIO power-on default
        BIC     #LOCKLPM5,&PM5CTL0        ; high-impedance mode to activade
                                        ; previously configured port settings

setupDisplayAndPorts:
        ; Manage Ports 
        ; Port 1
        MOV.b   #11111001B, &P1DIR        ; set P1.1/2 to input (input = 0)
        MOV.b   #00000110B, &P1REN        ; Activate P1.1/2 pull-up/down resistors
        BIS.b   #00000110B, &P1OUT        ; set P1.1/2 pull down resistor
        BIC.b   #BIT0,&P1OUT              ; set P1.0 LED off 


        // Port 9 (DEBUG -- Only for LED)
        BIS.b   #0xFF,&P9DIR              ; Set all P9 pins for output
        BIC.b   #0x80,&P9OUT              ; set P9.7 LED off


        ; Enable LCD segments: 0-21, 26-43
        MOV     #0xFFFF, &LCDCPCTL0     ; 1111111111111111
        MOV     #0xFC3F, &LCDCPCTL1     ; 1111110000111111, Q: why the 0's? Why ignore 22-25?
        MOV     #0x0FFF, &LCDCPCTL2     ; 1111111111111111
          
        ; Initialize LCD 
        MOV     #0x041e,&LCDCCTL0       ; sets display with hardware specs needed
        MOV     #0x0208, &LCDCVCTL      ; enable voltage for display
        MOV     #0x8000, &LCDCCPCTL     ; enable clock synchronization
        MOV     #2, &LCDCMEMCTL         ; clear LCD memory (resets screen)
        BIS     #1, &LCDCCTL0            ; turn the LCD on



; Everything under here will loop each time the program finishes
mainLoop:
        CALL    #reset                  ; Reset all needed registers/values
        CALL    #startProgram
        JMP     mainLoop
        
        CALL    #endProgram             ; Never runs, as mainLoop goes on forever


;================================== RESET SUBROUTINE ===========================
; Perform "Housekeeping" -- where we set every register/value to a default val
reset:
        MOV     #0, R4                  ; R4 = Current Page/State
                                        ;       0 = Title       <-- start
                                        ;       1 = Name Loop
                                        ;       2 = Menu -- Question 1 (Sign?)
                                        ;       3 = Menu -- Question 2 (D --> B)
                                        ;       4 = Menu -- Question 3.a (Digs?)
                                        ;       5 = Menu -- Question 3.b (Bits?)
                                        ;       6 = Input Number Screen
                                        ;       7 = Error
                                        ;       8 = Conversion State
                                                
                                        ;       ...

        MOV     #0, R5                  ; R5 = Current Name
                                        ;       * 0 = Name 1
                                        ;       * 1 = Name 2
                                        ;       * 2 = Name 3
                                        ;       * 3 = Name 4

        MOV     #0, R6                  ; R6 = Signed/Unsigned boolean
        MOV     #0, R7                  ; R7 = Dec -> Bin boolean / delay register
        MOV     #0, R8                  ; R8 = # of integer bits [0-6 binary, 1-2 decimal]

        MOV     #0, R9                  ; R9 = P1 Value (S1 = Bit 1, S2 = Bit 2)

        MOV     #2, &LCDCMEMCTL         ; clear LCD memory (resets screen)

        RET
        
;================================== RESET SUBROUTINE END =======================
        
startProgram:
        
        CALL    #checkButtonInput
        CALL    #displayCurrentPage
        
        
        ; Temporary check to determine if we need to continue looping
        ; see TODO's #4
        CMP     #9, R4
        JL      startProgram
        
        RET                             ; Jump back to "main"


;=========================== CHECK BUTTON SUBROUTINE ===========================
checkButtonInput:
        ; Check if S1 was pressed
        ; If S1 was pressed, do an action based on the current page

        MOV.b   &P1IN, R9               ; Get button state from P1 
        AND.b   #00000110B, R9          ; Apply bit mask to value
        CMP.b   #00000100B, R9          ; Check if S1 was pressed (sets to 0 when pressed)
        
        ; Skip to checking S2
        JNE     checkS2                 ; S1 wasn't pressed, check S2
        
        ; Call a delay, in case it was a false alarm
        CALL    #delay
        
        ; Check once again. If it's true, it should be correct
        MOV.b   &P1IN, R9               ; Get button state from P1 
        AND.b   #00000110B, R9          ; Apply bit mask to value

        ; Check if S1 was unpressed (sets to 0 when pressed)
        ; This is to prevent holding the button
        CMP.b   #00000100B, R9          

        JNE     jumpToPerformActionForS1
        JMP     endButtonCheck
        
checkS2:           
        ; Check if S2 was pressed
        ; If S2 was pressed, do an action based on the current page

        MOV.b   &P1IN, R9               ; Get button state from P1 
        AND.b   #00000110B, R9          ; Apply bit mask to value
        CMP.b   #00000010B, R9          ; Check if S2 was pressed (sets to 0 when pressed)
        
        JNE     endButtonCheck          ; S2 wasn't pressed, end button check
        
        ; Call a delay, in case it was a false alarm
        CALL    #delay
        
        
        ; Check once again. If it's true, it should be correct
        MOV.b   &P1IN, R9               ; Get button state from P1 
        AND.b   #00000110B, R9          ; Apply bit mask to value

        ; Check if S2 was unpressed (sets to 0 when pressed)
        ; This is to prevent holding the button
        CMP.b   #00000010B, R9         
        JNE     jumpToPerformActionForS2
        JMP     endButtonCheck
                
jumpToPerformActionForS1:
        CALL    #performActionForS1
        JMP     endButtonCheck
        
jumpToPerformActionForS2:
        CALL    #performActionForS2
        
endButtonCheck:
//        // DEBUG: Turn LEDs OFF
//        CMP.b   #0x6, R9
//        JEQ     turnOffLEDs
//        RET                             ; Return back to "startProgram"

//turnOffLEDs:
//        BIC.b   #BIT0, &P1OUT
//        BIC.b   #0x80, &P9OUT
        RET                             ; Return back to "startProgram"
        
;=========================== CHECK BUTTON SUBROUTINE END========================


;=============================== S1 BUTTON ACTION ==============================

performActionForS1:
        // DEBUG: Turn P1.0 ON and P9.7 OFF
        BIS.b   #BIT0, &P1OUT
        BIC.b   #0x80, &P9OUT
;        CALL    #delay                  // Show the LED
        
        CMP     #0, R4
        JEQ     performS1ActionForPage0
        
        CMP     #1, R4
        JEQ     performS1ActionForPage1
        
        CMP     #2, R4
        JEQ     performS1ActionForPage2
        
        CMP     #3, R4
        JEQ     performS1ActionForPage3
        
        CMP     #4, R4
        JEQ     performS1ActionForPage4
        
        CMP     #5, R4
        JEQ     performS1ActionForPage5
        
        CMP     #6, R4
        JEQ     performS1ActionForPage6
        
        CMP     #7, R4
        JEQ     performS1ActionForPage7
        
        CMP     #8, R4
        JEQ     performS1ActionForPage8
        
; We need to check what page we are on!
; Depending on the page, we need to perform different actions:
        
performS1ActionForPage0:        ; Title
        ; R4 = 1
        MOV     #1, R4
        RET
        
        
performS1ActionForPage1:        ; Name Loop
        ; R5++ % 4
        INC     R5
        CMP     #4, R5
        JL      endS1Page1Action
        MOV     #0, R5                  ; Reset R5
        
endS1Page1Action:
        RET
        
performS1ActionForPage2:        ; Signed or Unsigned?
        ; Toggle R6
        XOR     #BIT0, R6
        RET
        
performS1ActionForPage3:        ; Dec --> Bin?
        ; Toggle R7
        XOR     #BIT0, R7
        RET
        
performS1ActionForPage4:        ; Digs?
        ; Toggle R8
        XOR     #BIT0, R8
        RET
        
performS1ActionForPage5:        ; Bits?
        ; R8++ % 7
        INC     8
        CMP     #7, R8
        JL      endS1Page5Action
        MOV     #0, R8                  ; Reset R8
        
endS1Page5Action:
        RET
        
performS1ActionForPage6:        ; Number Choosing
        ; TEMP: Skip to Page 8
        MOV     #8, R4
        RET                             ; TODO

performS1ActionForPage7:        ; Error
        ; R4 = 6
        MOV     #6, R4
        RET
        
performS1ActionForPage8:        ; Conversion State
        ; R4 = 9
        MOV     #9, R4                  ; This will cause the program to loop "mainLoop"
        RET

;=============================== S1 BUTTON ACTION END===========================

;=============================== S2 BUTTON ACTION ==============================

performActionForS2:
        // DEBUG: Turn P1.0 OFF and P9.7 ON
        BIC.b   #BIT0, &P1OUT
        BIS.b   #0x80, &P9OUT
;        CALL    #delay                  // Show the LED
        
        CMP     #0, R4
        JEQ     performS2ActionForPage0
        
        CMP     #1, R4
        JEQ     performS2ActionForPage1
        
        CMP     #2, R4
        JEQ     performS2ActionForPage2
        
        CMP     #3, R4
        JEQ     performS2ActionForPage3
        
        CMP     #4, R4
        JEQ     performS2ActionForPage4
        
        CMP     #5, R4
        JEQ     performS2ActionForPage5
        
        CMP     #6, R4
        JEQ     performS2ActionForPage6
        
        CMP     #7, R4
        JEQ     performS2ActionForPage7
        
        CMP     #8, R4
        JEQ     performS2ActionForPage8
        
; We need to check what page we are on!
; Depending on the page, we need to perform different actions:
                
performS2ActionForPage0:        ; Title
        ; R4 = 2
        MOV     #2, R4
        RET
performS2ActionForPage1:        ; Name Loop
        ; R4 = 2
        MOV     #2, R4
        RET
performS2ActionForPage2:        ; Sign?
        ; R4 = 3
        MOV     #3, R4
        RET
performS2ActionForPage3:        ; Dec --> Bin?
        ; R4 = 4 if R6 =0, else R4 = 5
        MOV     #4, R4
        CMP     #0, R6
        JEQ     endS2Page3Action
        INC.b   R4

endS2Page3Action:
        RET
        
performS2ActionForPage4:        ; Digs?
        ; R4 = 6
        MOV     #6, R4
        RET
performS2ActionForPage5:        ; Bits?
        ; R4 = 6
        MOV     #6, R4
        RET
performS2ActionForPage6:        ; Number Choosing
        ; TEMP: Move to Page 8
        MOV     #8, R4
        ; TODO
        RET
performS2ActionForPage7:        ; Error
        ; R4 = 6
        MOV     #6, R4
        RET    
performS2ActionForPage8:        ; Conversion
        ; R4 = 9
        MOV     #9, R4                  ; This will cause the program to loop "mainLoop"
        RET
        

;=============================== S2 BUTTON ACTION END===========================
        

;=========================== DISPLAY SUBROUTINE ================================

displayCurrentPage:
        CMP     #0, R4                  
        JEQ     displayTitleScreen      ; Maybe we need to use CALL instead of JMP.
                                        ; Same goes for below.
        
        CMP     #1, R4
        JEQ     displayNames
        
        CMP     #2, R4
        JEQ     displaySignedQuestion
        
        CMP     #3, R4
        JEQ     displayDecToBinQuestion
        
        CMP     #4, R4
        JEQ     displayDigitsQuestion
        
        CMP     #5, R4
        JEQ     displayBitsQuestion
        
        CMP     #6, R4
        JEQ     displayNumberInput
        
        CMP     #7, R4
        JEQ     displayError
        
        CMP     #8, R4
        JEQ     displayConversion        
        ; ...
        
        ; CMP     #2, R4
        ; JEQ     displayMenu
        
        RET


displayTitleScreen:

        MOV.b   #0x8E, &0xA29           ; F
        MOV.b   #0x22, &0xA26           ; (
        MOV.b   #0xCF, &0xA23           ; P
        MOV.b   #0x01, &0xA24           ; .
        MOV.b   #0xFC, &0xA32           ; Q
        MOV.b   #0x02, &0xA33           ; Q (line)
        MOV.b   #0x88, &0xA2F           ; )
        
        RET                             ; Return back to "startProgram"


displayNames:
        ; IDEA: We might not even need to have all these indexings!
        ; We can just simply use R5 as the index to the name arrays
        ; That way all we do is:
        ;       * Display R5th Name
        ;       * Return
        CMP     #0, R5
        JEQ     displayName1
        
        CMP     #1, R5
        JEQ     displayName2        
        
        CMP     #2, R5
        JEQ     displayName3        
        
        CMP     #3, R5
        JEQ     displayName4
        
        
displayName1:
        MOV.B   #0xCF, &0xA29           ;R high byte
        MOV.B   #0x02, &0xA2A           ;R low byte
        MOV.B   #0x90, &0xA25           ;I high byte
        MOV.B   #0x50, &0xA26           ;I low byte
        MOV.B   #0x9C, &0xA23           ;C high byte
        MOV.B   #0x00, &0xA24           ;C low byte
        MOV.B   #0xEF, &0xA32           ;A high byte
        MOV.B   #0x00, &0xA33           ;A low byte
        MOV.B   #0xCF, &0xA2E           ;R high byte
        MOV.B   #0x02, &0xA2F           ;R low byte
        MOV.B   #0xF0, &0xA27           ;D high byte
        MOV.B   #0x50, &0xA28           ;D low byte
        RET                             ; Return back to "startProgram"
        
displayName2:
        MOV.B #0x78 , &0xA29            ;J high byte
        MOV.B #0x00 , &0xA2A            ;J low byte
        MOV.B #0xEF , &0xA25            ;A high byte
        MOV.B #0x00 , &0xA26            ;A low byte
        MOV.B #0x6C , &0xA23            ;N high byte
        MOV.B #0x82 , &0xA24            ;N low byte
        MOV.B #0x6C , &0xA32            ;N high byte
        MOV.B #0x82 , &0xA33            ;N low byte
        MOV.B #0x00 , &0xA2E            ;empty
        MOV.B #0x00 , &0xA2F            ;empty
        MOV.B #0x00 , &0xA27            ;empty
        MOV.B #0x00 , &0xA28            ;empty
        RET                             ; Return back to "startProgram"

displayName3:
        MOV.B   #0x90, &0xA29           ;I high byte
        MOV.B   #0x50, &0xA2A           ;I low byte
        MOV.B   #0xB1, &0xA25           ;S high byte
        MOV.B   #0x80, &0xA26           ;S low byte
        MOV.B   #0xEF, &0xA23           ;A high byte
        MOV.B   #0x00, &0xA24           ;A low byte
        MOV.B   #0xF1, &0xA32           ;B high byte
        MOV.B   #0x50, &0xA33           ;B low byte
        MOV.B   #0x9F, &0xA2E           ;E high byte
        MOV.B   #0x00 , &0xA2F          ;E low byte
        MOV.B   #0x1C, &0xA27           ;L high byte
        MOV.B   #0x00 , &0xA28          ;L low byte
        RET                             ; Return back to "startProgram"
        
displayName4:
        MOV.B   #0x0C, &0xA29           ;V high byte
        MOV.B   #0x28, &0xA2A           ;V low byte
        MOV.B   #0xEF, &0xA25           ;A high byte
        MOV.B   #0x00, &0xA26           ;A low byte
        MOV.B   #0x6c, &0xA23           ;N high byte
        MOV.B   #0x82, &0xA24           ;N low byte
        MOV.B   #0xF0, &0xA32           ;D high byte
        MOV.B   #0x50, &0xA33           ;D low byte
        MOV.B   #0x90, &0xA2E           ;I high byte
        MOV.B   #0x50, &0xA2F           ;I high byte
        MOV.B   #0x9F, &0xA27           ;E
        RET                             ; Return back to "startProgram"
        
        
; displayMenu:
;         RET                             ; Return back to "startProgram"

displaySignedQuestion:
displayDecToBinQuestion:
displayDigitsQuestion:
displayBitsQuestion:
displayNumberInput:
displayError:
displayConversion:
          RET

;=========================== DISPLAY SUBROUTINE ================================


;=========================== DELAY SUBROUTINE ==================================
delay:  ; Used to delay the program
        ; giving the MSP time to handle
        ; button pressed (debouncing)

        PUSH.w    R7                      ; Preserve Original Value                       
        CALL    #delayStart
        POP     R7                      ; Restore Original Value
        RET
        
delayStart:
        MOV     #0xFFFF,R7              ; Set R7 to an abnormally high value       


next:   ; Decrease R7 all the way to 0
        DEC     R7                       
        JNZ     next
        RET
;=========================== DELAY SUBROUTINE ==================================



endProgram:
        JMP $                           ; jump to current location '$'
                                        ; (endless loop)

        NOP
        END
